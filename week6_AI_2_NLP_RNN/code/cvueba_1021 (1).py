# -*- coding: utf-8 -*-
"""CVUEBA_1021.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/126u432bmUw5NnuYyBvHdw5U4AyBlU7YL
"""

!git clone https://github.com/sameerkhanna786/CVUEBA.git

ls

cd CVUEBA

ls

!pip install -r requirements.txt

!bash run.sh

cd ..

import numpy as np
import cv2
import random
import shutil
import os
from tqdm import tqdm

"""
Novel augmentations proposed in the paper.
For demonstration purposes, we only apply
each augmentation once per attack encoding.
"""

IN_FOLDER = "TrainImages"
OUT_FOLDER = "AugImages"

def channel_swap(path, in_folder, out_folder):
	im = cv2.imread(path)
	channel_1 = im[:, :, 0]
	channel_2 = im[:, :, 1]
	channel_3 = im[:, :, 2]
	stack = np.stack((channel_2, channel_1, channel_3), axis=-1)

	file_name = path.split(".")[0]
	file_type = path.split(".")[1]
	write_name = f"{file_name}_swap.{file_type}"
	write_name = write_name.replace(in_folder, out_folder)
	cv2.imwrite(write_name, stack)

def get_user_from_path(path):
	file = path.split("/")[2]
	return file.split("_")[0]

def get_random_benign_from_user(user):
	folder = os.path.join(IN_FOLDER, "0")
	files = [f for f in os.listdir(folder) if os.path.isfile(os.path.join(folder, f))]
	userfiles = [f for f in files if user in f]
	if len(userfiles) == 0:
		return None
	choice_file = random.choice(userfiles)
	return os.path.join(folder, choice_file)

def channel_replace(path, in_folder, out_folder):
	im = cv2.imread(path)
	channel_3 = im[:, :, 2]

	im_user = get_user_from_path(path)
	rand_path = get_random_benign_from_user(im_user)
	if rand_path is None:
		return
	rand_im = cv2.imread(rand_path)
	channel_1 = rand_im[:, :, 0]
	channel_2 = rand_im[:, :, 1]

	stack = np.stack((channel_1, channel_2, channel_3), axis=-1)

	file_name = path.split(".")[0]
	file_type = path.split(".")[1]
	write_name = f"{file_name}_replace.{file_type}"
	write_name = write_name.replace(in_folder, out_folder)
	cv2.imwrite(write_name, stack)

try:
	os.makedirs(f"{OUT_FOLDER}/0")
except:
	pass

try:
	os.makedirs(f"{OUT_FOLDER}/1")
except:
	pass

try:
	os.makedirs(f"{OUT_FOLDER}/2")
except:
	pass

try:
	os.makedirs(f"{OUT_FOLDER}/3")
except:
	pass

# Do not augment benign images. Just copy those over
#shutil.copytree(f"{IN_FOLDER}/0", f"{OUT_FOLDER}/0")
#shutil.copytree(f"{IN_FOLDER}/0", f"{OUT_FOLDER}/0", dirs_exist_ok=True)
for scenario in [1, 2, 3]:
	directory_path = os.path.join(IN_FOLDER, str(scenario))
	images = [f for f in os.listdir(directory_path) if os.path.isfile(os.path.join(directory_path, f))]
	for image in tqdm(images):
		path = os.path.join(directory_path, image)
		channel_swap(path, IN_FOLDER, OUT_FOLDER)
		channel_replace(path, IN_FOLDER, OUT_FOLDER)

ls

!python3 CVUEBA.py

import pandas as pd
from sklearn.preprocessing import MinMaxScaler
import tensorflow as tf
#from tensorflow.python.keras.applications.resnet import ResNet50
#from tensorflow.python.keras.models import Sequential, Model
#from tensorflow.python.keras.layers import *
from tensorflow.keras.applications.resnet import ResNet50
from tensorflow.keras.models import Sequential, Model
from tensorflow.keras.layers import *
from sklearn.model_selection import train_test_split
import numpy as np
import ssl
from sklearn.metrics import *
from prep_data_model import *

"""
Load or Train dual-input classifier.
Use the data loading API defined in prep_data_model
to extract data
"""

# Need to download ResNet weight (trained on ImageNet)
# This circumvents potential download issues of weights.
ssl._create_default_https_context = ssl._create_unverified_context

print("Loading data...")
#images, non_behave, y = load_data("AugImages")
images, non_behave, y = load_data("TestImages")
y[y != 0] = 1

print("...Done")

res_model = ResNet50(include_top = False, pooling = "avg", input_shape=(32, 32, 3))
for i, layer in enumerate(res_model.layers):
	if i <= 170:
		layer.trainable = False
	print(f"Layer {i} Out: {layer} Trainable: {layer.trainable}")

try:
	model = tf.keras.models.load_model("cvueba")
	print("Finished Loading Model!")
except:
	print("Model not found. Generating and training!")

	image_input = Input(shape=(32, 32, 3))
	vector_input = Input(shape=(47,))
	res_out = res_model(image_input)

	concat_layer = Concatenate()([vector_input, res_out])

	out = Dense(1024, activation='relu', kernel_regularizer="l2")(concat_layer)
	out = Dense(512, activation='relu', kernel_regularizer="l2")(out)
	out = Dense(256, activation='relu', kernel_regularizer="l2")(out)
	out = Dense(1, activation='sigmoid')(out)

	model = Model(inputs=[image_input, vector_input], outputs=out)

	METRICS = [
		tf.keras.metrics.BinaryAccuracy(name='accuracy'),
		tf.keras.metrics.Precision(name='precision'),
		tf.keras.metrics.Recall(name='recall'),
	]

	model.compile(loss='binary_crossentropy', optimizer="adam", metrics=METRICS)
	model.fit([images, non_behave], y, batch_size=128, epochs=100, shuffle=True)

	model.save("cvueba")

test_images, test_non_behave, y_test = load_data("TestImages")
y_test[y_test!=0] = 1

print("Predicting...")
y_pred = model.predict([test_images, test_non_behave])
y_pred[y_pred <= 0.5] = 0
y_pred[y_pred > 0.5] = 1
print("...Finished!")

bal_accuracy = balanced_accuracy_score(y_test, y_pred)
f1 = f1_score(y_test, y_pred)
precision = precision_score(y_test, y_pred)
recall = recall_score(y_test, y_pred)

print(f"Balanced Accuracy: {bal_accuracy}")
print(f"F1 Score: {f1}")
print(f"Precision: {precision}")
print(f"Recall: {recall}")